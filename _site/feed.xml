<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.7.3">Jekyll</generator><link href="http://localhost:4000/old/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/old/" rel="alternate" type="text/html" /><updated>2018-10-24T22:42:20+09:00</updated><id>http://localhost:4000/old/</id><title type="html">SUNDRYCODES</title><subtitle>짤막한, 아니면 기억하고 싶은 잡스런 코드나 약간의 주절거림이 있는 개인 블로그입니다.</subtitle><entry><title type="html">매일프로그래밍 실리콘밸리 패키지 문제 10</title><link href="http://localhost:4000/old/%EB%A7%A4%EC%9D%BC%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/2018/08/21/%EB%A7%A4%EC%9D%BC%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%8B%A4%EB%A6%AC%EC%BD%98%EB%B0%B8%EB%A6%AC-%ED%8C%A8%ED%82%A4%EC%A7%80-%EB%AC%B8%EC%A0%9C-10.html" rel="alternate" type="text/html" title="매일프로그래밍 실리콘밸리 패키지 문제 10" /><published>2018-08-21T00:00:00+09:00</published><updated>2018-08-21T00:00:00+09:00</updated><id>http://localhost:4000/old/%EB%A7%A4%EC%9D%BC%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/2018/08/21/%EB%A7%A4%EC%9D%BC%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%8B%A4%EB%A6%AC%EC%BD%98%EB%B0%B8%EB%A6%AC-%ED%8C%A8%ED%82%A4%EC%A7%80-%EB%AC%B8%EC%A0%9C-10</id><content type="html" xml:base="http://localhost:4000/old/%EB%A7%A4%EC%9D%BC%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/2018/08/21/%EB%A7%A4%EC%9D%BC%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%8B%A4%EB%A6%AC%EC%BD%98%EB%B0%B8%EB%A6%AC-%ED%8C%A8%ED%82%A4%EC%A7%80-%EB%AC%B8%EC%A0%9C-10.html">&lt;p&gt;&lt;em&gt;안녕하세요, 매일프로그래밍 이번주 문제입니다.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;String이 주어지면, 중복된 char가 없는 가장 긴 서브스트링 (substring)의 길이를 찾으시오.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Given a string, find the longest substring that does not have duplicate characters.&lt;/em&gt;&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;em&gt;예제)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Input: “aabcbcbc”&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Output: 3 // “abc”&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Input: “aaaaaaaa”&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Output: 1 // “a”&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Input: “abbbcedd”&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;﻿&lt;em&gt;Output: 4 // “bced”&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;풀이를 보고 싶으시다면 &lt;a href=&quot;http://url6080.mailprogramming.com/wf/click?upn=5YNwhcR4-2FFhQA54IFFE-2FIijGnZEwyyYieIxIap6l3O-2F45Kr4FUGWF6dqpC95cdkgWkZdD4qQzq6jGRLPzeYD4U3UNKLhsE7ixWuvqFUNqkZIhgp5xi-2F6MgrMbnTDDj6FLR-2B-2FbdQFcarRHHIOHTx-2Br5gz6Be27YY1qPc9sdPx3Cs5Kcx0xBTPbqnmbrg8zaxs_Zgoc2ijnN3jtNTS7ITLZKrJdLqoKRo6qqLK1adFq7tfKml2T-2FZpRTvK762Qx0KqP8hZfNth1-2FWGeLDjC0MA6izvl1fraT6qr25VNJZqYSwrq4zqGE8ST-2Bk0JbVsP1IMZhRDh8pqGIbYZ9Gwru10xuH3-2FLuCxWdnJDOSTnGebrEA7G600IdwS1pAbWgA739CQJRAX7v9gP3njUO067uJh2-2FDRDLxthLGlfE16p9GhSMDDoVuMdwNVJ7i4xpXzli2a&quot;&gt;풀이보기&lt;/a&gt;를 눌러주세요.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;연속으로 substring들을 수집하되 가장 긴 substring을 따로 저장하는 코드이다. &lt;code class=&quot;highlighter-rouge&quot;&gt;j&lt;/code&gt;는 새로운 substring이 시작되는 위치이고, &lt;code class=&quot;highlighter-rouge&quot;&gt;length&lt;/code&gt;는 그 substring의 길이를 나타낸다. 어떤 문자열이라도 길이가 0인 문자가 아니라면 최소 substring의 길이는 1일 것이므로 이를 초기값으로 했다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ans&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;max_length_str&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;''&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;length&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;continue&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]:&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;length&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;length&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;max_length_str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;max_length_str&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'{} {}'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;format&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]))&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;max_length_str&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;그런데 만약 중복되지 않는 substring 중에 길이가 같은 게 있으면 어떻게 하는 것인가? 예를 들어 &lt;code class=&quot;highlighter-rouge&quot;&gt;abcdcba&lt;/code&gt; 같은 경우 말이다. 여기에는 중복되지 않는 두 개의 substring, &lt;code class=&quot;highlighter-rouge&quot;&gt;abcd&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;dcba&lt;/code&gt;가 같은 길이로 2개 존재한다.&lt;/p&gt;

&lt;p&gt;풀이를 보자. 아차, 문제에서 요구한 답은 조건을 만족하는 최대 substring의 &lt;em&gt;길이&lt;/em&gt; 였다. &lt;code class=&quot;highlighter-rouge&quot;&gt;max_length_str&lt;/code&gt;가 필요 없게 되었다. &lt;code class=&quot;highlighter-rouge&quot;&gt;length&lt;/code&gt;값의 최대값만 구하면 될 것이다.&lt;/p&gt;

&lt;p&gt;풀이에서는 자바의 해쉬맵을 사용했다. string의 각 char를 확인하여 해쉬맵에 있다면 substring의 시작 index를 그 다음 char의 인덱스로 두면 된다고 한다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;sol&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;start&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;s_dict&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;dict&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)):&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s_dict&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;start&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s_dict&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;start&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;s_dict&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;매번 느끼는 것이지만 자바를 파이썬으로 바꾸면 코드가 짧아지는 경향이 있다.&lt;/p&gt;

&lt;p&gt;자바 코드를 변환하다가 리스트를 일단 딕셔너리 형으로 바꿔야 하는 줄 알고 찾아보니 다음과 같은 방법이 있었다. 기억해놔야 겠다. 만약 리스트를 바로 { list[i] : i }와 같은 딕셔너리로 바꾸고 싶다면 사용하자.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;n&quot;&gt;s_dict&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;</content><author><name></name></author><category term="매일프로그래밍" /><category term="mailprogramming" /><summary type="html">안녕하세요, 매일프로그래밍 이번주 문제입니다. String이 주어지면, 중복된 char가 없는 가장 긴 서브스트링 (substring)의 길이를 찾으시오. Given a string, find the longest substring that does not have duplicate characters.</summary></entry><entry><title type="html">매일프로그래밍 실리콘밸리 패키지 문제 9</title><link href="http://localhost:4000/old/%EB%A7%A4%EC%9D%BC%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/2018/08/20/%EB%A7%A4%EC%9D%BC%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%8B%A4%EB%A6%AC%EC%BD%98%EB%B0%B8%EB%A6%AC-%ED%8C%A8%ED%82%A4%EC%A7%80-%EB%AC%B8%EC%A0%9C-9.html" rel="alternate" type="text/html" title="매일프로그래밍 실리콘밸리 패키지 문제 9" /><published>2018-08-20T00:00:00+09:00</published><updated>2018-08-20T00:00:00+09:00</updated><id>http://localhost:4000/old/%EB%A7%A4%EC%9D%BC%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/2018/08/20/%EB%A7%A4%EC%9D%BC%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%8B%A4%EB%A6%AC%EC%BD%98%EB%B0%B8%EB%A6%AC-%ED%8C%A8%ED%82%A4%EC%A7%80-%EB%AC%B8%EC%A0%9C-9</id><content type="html" xml:base="http://localhost:4000/old/%EB%A7%A4%EC%9D%BC%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/2018/08/20/%EB%A7%A4%EC%9D%BC%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%8B%A4%EB%A6%AC%EC%BD%98%EB%B0%B8%EB%A6%AC-%ED%8C%A8%ED%82%A4%EC%A7%80-%EB%AC%B8%EC%A0%9C-9.html">&lt;p&gt;&lt;em&gt;안녕하세요, 매일프로그래밍 이번주 문제입니다.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;정수 배열(int array)이 주어지면 0이 아닌 정수 순서를 유지하며 모든 0을 배열 오른쪽 끝으로 옮기시오. 단, 시간복잡도는 O(n), 공간복잡도는 O(1)여야 합니다.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Given an integer array, move all the 0s to the right of the array without changing the order of non-zero elements.&lt;/em&gt;&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;em&gt;예제)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Input: [0, 5, 0, 3, -1]&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Output: [5, 3, -1, 0, 0]&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Input: [3, 0, 3]&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;﻿&lt;em&gt;Output: [3, 3, 0]&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;풀이를 보고 싶으시다면 &lt;a href=&quot;http://url6080.mailprogramming.com/wf/click?upn=5YNwhcR4-2FFhQA54IFFE-2FIijGnZEwyyYieIxIap6l3O8TZMVFc6s-2B8FK0wYQmKQSf5VgwzgsPa40Hzn1zHKmMxVF1nHi6YkD4kcT9L0M4H4na6HIJqwHfS-2BEg9hrSxbcH-2BZfJE6Z-2FhjsaLO6L5dgTs-2BiFbIiiq4NiZwIqIYqHbJpMyM-2BkKIWBEADBeFTqTuUq_Zgoc2ijnN3jtNTS7ITLZKrJdLqoKRo6qqLK1adFq7tfLS63zSOMEFzba0-2Bj5X3eeTHHuA3cQtIz2KQdM3yF-2F-2F17dnFNqB6BnoIzGhgvCXGJYV3kyX7G1CyiQbEOlcblQs8fJux8ClBY42PXE5SAHU8gSQ2Tx2nSuI0FA5anGIcYl2pu6WPIYxWv1J1h9dp7jw7jU3xHAAx0qzUYs-2Fq4k5Lz7yNnSRG3i4zNoYVnQ7KFWKylHJ-2BxV60GJ0St2grp7&quot;&gt;풀이보기&lt;/a&gt;를 눌러주세요.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;0이 아닌 정수의 리스트에 정수가 아닌 원소를 하나씩 담고 원소가 0일 때마다 그 갯수를 세어 마지막에 채우는 알고리즘을 작성해 봤다. 여기서 공간복잡도의 조건은 충족시키지 못했다. 기존 배열을 직접 수정하여야 충족 가능한 듯 싶다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ans&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;arr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;non_zero_arr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;non_zero_arr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;arr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;non_zero_arr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)):&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;non_zero_arr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;non_zero_arr&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;풀이는 역시 기대를 저버리지 않는다. &lt;em&gt;0을 오른쪽으로 옮기는 것 보다 0이 아닌 정수를 왼쪽으로 옮긴다고 생각하면 쉽게 풀 수 있다&lt;/em&gt; 고 한다…&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;sol&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;arr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;# 0이 아닌 정수의 위치를 표현하는 j&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;arr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)):&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;arr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arr&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;풀이에서 사용하는 언어는 자바여서 &lt;code class=&quot;highlighter-rouge&quot;&gt;a, b = b, a&lt;/code&gt;와 같은 구문이 불가능하다. 때문에 swap() 함수를 따로 정의하여 사용했는데, 파이썬에서는 그럴 필요가 없어 그대로 사용했다.&lt;/p&gt;</content><author><name></name></author><category term="매일프로그래밍" /><category term="mailprogramming" /><summary type="html">안녕하세요, 매일프로그래밍 이번주 문제입니다. 정수 배열(int array)이 주어지면 0이 아닌 정수 순서를 유지하며 모든 0을 배열 오른쪽 끝으로 옮기시오. 단, 시간복잡도는 O(n), 공간복잡도는 O(1)여야 합니다. Given an integer array, move all the 0s to the right of the array without changing the order of non-zero elements.</summary></entry><entry><title type="html">매일프로그래밍 실리콘밸리 패키지 문제 8</title><link href="http://localhost:4000/old/%EB%A7%A4%EC%9D%BC%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/2018/08/20/%EB%A7%A4%EC%9D%BC%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%8B%A4%EB%A6%AC%EC%BD%98%EB%B0%B8%EB%A6%AC-%ED%8C%A8%ED%82%A4%EC%A7%80-%EB%AC%B8%EC%A0%9C-8.html" rel="alternate" type="text/html" title="매일프로그래밍 실리콘밸리 패키지 문제 8" /><published>2018-08-20T00:00:00+09:00</published><updated>2018-08-20T00:00:00+09:00</updated><id>http://localhost:4000/old/%EB%A7%A4%EC%9D%BC%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/2018/08/20/%EB%A7%A4%EC%9D%BC%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%8B%A4%EB%A6%AC%EC%BD%98%EB%B0%B8%EB%A6%AC-%ED%8C%A8%ED%82%A4%EC%A7%80-%EB%AC%B8%EC%A0%9C-8</id><content type="html" xml:base="http://localhost:4000/old/%EB%A7%A4%EC%9D%BC%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/2018/08/20/%EB%A7%A4%EC%9D%BC%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%8B%A4%EB%A6%AC%EC%BD%98%EB%B0%B8%EB%A6%AC-%ED%8C%A8%ED%82%A4%EC%A7%80-%EB%AC%B8%EC%A0%9C-8.html">&lt;p&gt;&lt;em&gt;안녕하세요, 매일프로그래밍 이번주 문제입니다.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;정수 배열(int array)이 주어지면 두번째로 큰 값을 프린트하시오.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Given an integer array, find the second largest element.&lt;/em&gt;&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;em&gt;예제)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Input: [10, 5, 4, 3, -1]&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Output: 5&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Input: [3, 3, 3]&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Output: Does not exist.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;풀이를 보고 싶으시다면 &lt;a href=&quot;http://url6080.mailprogramming.com/wf/click?upn=5YNwhcR4-2FFhQA54IFFE-2FIijGnZEwyyYieIxIap6l3O9sdn2G3Le95Ma9-2FPmAfFWHPtborW-2B202XJ4ImfpHD0i9XC6uqfqngq62bAuEcrzuG-2FDJeXu4x0nmT45-2B4ReRFyFrJ7h7VQYIyvftkHKCfZPbltiKOy3crXJclsznRumE5NASS-2BIMvQJRggezDfYfa6_Zgoc2ijnN3jtNTS7ITLZKrJdLqoKRo6qqLK1adFq7tddpJG04AwedeDK5qWFGZyz5IoxmfeXLCDEFlnVT-2B8BqO9zzl3YGqOSZuED-2BbiT9D4Xgo7BHcVMXJapSULzlA0T2DI-2BAW-2FNMO1I-2BhEjSHQwWlzh0ba-2FLDTVDD0e-2Bw6XNuSeV5fO8zcN0SET33UKAjskFv-2BAkjOzV1u2xEV0-2FqfSt5X8HlCk1n6MoyTpUjrHKgGHKXrqyGtVD-2FOL2dZU8Fcv&quot;&gt;풀이보기&lt;/a&gt;를 눌러주세요.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;정렬 후 최대값과 그보다 작은 값을 저장하는 방법을 생각해봤다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ans&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;int_arr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;int_arr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;sorted&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;int_arr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;first&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;second&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;int_arr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;int_arr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;continue&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;first&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;first&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;second&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;first&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;elif&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;second&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;first&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;second&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;first&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;second&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'Does not exists.'&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;second&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;풀이에서는 일단, 정렬하지 않고, first, second 값의 선언을 할 때 자바에서 지원하는 정수의 최소값( Integer.MIN_VALUE )을 넣어 그것이 바뀌었는지를 판단하였다. 파이썬3에서는 그런 게 정의되지 않는다고 한다… 파이썬 2에서는 오버플로우를 이용하여 &lt;code class=&quot;highlighter-rouge&quot;&gt;-sys.maxint-1&lt;/code&gt;으로 최소값을 구할 수 있는 모양이다. 본인은 파이썬 3을 사용하고 있으므로, 다른 방법을 생각해야겠다.&lt;/p&gt;

&lt;p&gt;… 아니면 그냥 min()을 사용하여 입력값의 최소값으로 first, second를 초기화하면 되지 않을까?&lt;/p&gt;

&lt;p&gt;……아니면 그냥 정렬하는 것도 나쁘지 않은 방법인거 같다.&lt;/p&gt;

&lt;p&gt;풀이에서는 추가적으로 입력된 배열의 원소 개수가 2보다 작으면 역시 &lt;code class=&quot;highlighter-rouge&quot;&gt;Does not exists.&lt;/code&gt;를 출력하였다. &lt;em&gt;It makes sense!&lt;/em&gt;&lt;/p&gt;</content><author><name></name></author><category term="매일프로그래밍" /><category term="mailprogramming" /><summary type="html">안녕하세요, 매일프로그래밍 이번주 문제입니다. 정수 배열(int array)이 주어지면 두번째로 큰 값을 프린트하시오. Given an integer array, find the second largest element.</summary></entry><entry><title type="html">매일프로그래밍 실리콘밸리 패키지 문제 7</title><link href="http://localhost:4000/old/%EB%A7%A4%EC%9D%BC%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/2018/08/20/%EB%A7%A4%EC%9D%BC%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%8B%A4%EB%A6%AC%EC%BD%98%EB%B0%B8%EB%A6%AC-%ED%8C%A8%ED%82%A4%EC%A7%80-%EB%AC%B8%EC%A0%9C-7.html" rel="alternate" type="text/html" title="매일프로그래밍 실리콘밸리 패키지 문제 7" /><published>2018-08-20T00:00:00+09:00</published><updated>2018-08-20T00:00:00+09:00</updated><id>http://localhost:4000/old/%EB%A7%A4%EC%9D%BC%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/2018/08/20/%EB%A7%A4%EC%9D%BC%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%8B%A4%EB%A6%AC%EC%BD%98%EB%B0%B8%EB%A6%AC-%ED%8C%A8%ED%82%A4%EC%A7%80-%EB%AC%B8%EC%A0%9C-7</id><content type="html" xml:base="http://localhost:4000/old/%EB%A7%A4%EC%9D%BC%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/2018/08/20/%EB%A7%A4%EC%9D%BC%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%8B%A4%EB%A6%AC%EC%BD%98%EB%B0%B8%EB%A6%AC-%ED%8C%A8%ED%82%A4%EC%A7%80-%EB%AC%B8%EC%A0%9C-7.html">&lt;p&gt;&lt;em&gt;안녕하세요, 매일프로그래밍 이번주 문제입니다.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;주어진 string 에 모든 단어를 거꾸로 하시오.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Reverse all the words in the given string.&lt;/em&gt;&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;em&gt;예제)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Input: “abc 123 apple”&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Output: “cba 321 elppa”&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;풀이를 보고 싶으시다면 &lt;a href=&quot;http://url6080.mailprogramming.com/wf/click?upn=5YNwhcR4-2FFhQA54IFFE-2FIijGnZEwyyYieIxIap6l3O8VD7TP37Xl49W2TG8pxTYN9GZvVN9h3djM-2BqQ9dS0uR3spXmCgmyqqjr66mlKYtDc4I953MudVQ3kZ8d1cquEEA2Q99-2B-2FP9d5XlhO-2FSXl-2FmlhdRP-2BR0qEMX-2FpRPwGNzgOc7yrdqODV7Rnn-2BoirTsRc_Zgoc2ijnN3jtNTS7ITLZKrJdLqoKRo6qqLK1adFq7tcBbnn8kJrbQrVy56dQcnoolWNzBDP3hNZit1UFP6AdVb936LspnLwqPKrdp-2BCO7RC4HEpVz9ibRBylaZXRE4VWxB0za00p5ZjOcGaIAXmnB9f8PmC0cHBNMr5AKC-2BIen1RvYkXZB7qbOYBCKepX-2Byw34-2BZsQckA6kbOdwsxdxYRQZ0rXD7dV4CCweroSgpctTlt67LeQRkKpMN1XWQiuSG&quot;&gt;풀이보기&lt;/a&gt;를 눌러주세요.&lt;/em&gt;&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;어렵지 않게 작성했다. 입력한 문자열을 잘라서, 각각의 단어를 역순으로 배치한 다음, 다시 출력했다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;revrse&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;splited_string&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;split&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;word&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;enumerate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;splited_string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;enumerate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;word&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)):&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;st&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;word&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)[&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;splited_string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;word&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;word&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;word&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)]&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;reversed_string&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;''&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;word&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;splited_string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;word&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;splited_string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]:&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;reversed_string&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;word&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;reversed_string&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;word&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;' '&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;reversed_string&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;이번 풀이에는 어떤 혁신적인 알고리즘이 있을까?&lt;/p&gt;

&lt;p&gt;…별 게 없었다. 인터뷰 중에는 각 언어에 포함된 reverse()나 split()와 같은 종류의 내장 메서드는 사용할 수 없는 경우에 대비하여, 해당 기능을 하는 함수를 직접 만들어 작성한 풀이였다.&lt;/p&gt;

&lt;p&gt;그렇다면 나와 같은 경우는.. split() 메서드를 직접 만들면 되겠다. 앞으로는 enumerate()와 같은 메서드도 별도의 변수로 대체해서 구현해야겠다. 그러면 list()는…? 파이썬 기본 자료형 중 하나이니 사용금지당하지는 않지 않을까?…&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;splitSpace&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;split_space&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;a_word&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;''&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;' '&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;a_word&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;split_space&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a_word&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;split_space&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a_word&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;a_word&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;''&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;split_space&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;</content><author><name></name></author><category term="매일프로그래밍" /><category term="mailprogramming" /><summary type="html">안녕하세요, 매일프로그래밍 이번주 문제입니다. 주어진 string 에 모든 단어를 거꾸로 하시오. Reverse all the words in the given string.</summary></entry><entry><title type="html">매일프로그래밍 실리콘밸리 패키지 문제 6</title><link href="http://localhost:4000/old/%EB%A7%A4%EC%9D%BC%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/2018/08/19/%EB%A7%A4%EC%9D%BC%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%8B%A4%EB%A6%AC%EC%BD%98%EB%B0%B8%EB%A6%AC-%ED%8C%A8%ED%82%A4%EC%A7%80-%EB%AC%B8%EC%A0%9C-6.html" rel="alternate" type="text/html" title="매일프로그래밍 실리콘밸리 패키지 문제 6" /><published>2018-08-19T00:00:00+09:00</published><updated>2018-08-19T00:00:00+09:00</updated><id>http://localhost:4000/old/%EB%A7%A4%EC%9D%BC%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/2018/08/19/%EB%A7%A4%EC%9D%BC%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%8B%A4%EB%A6%AC%EC%BD%98%EB%B0%B8%EB%A6%AC-%ED%8C%A8%ED%82%A4%EC%A7%80-%EB%AC%B8%EC%A0%9C-6</id><content type="html" xml:base="http://localhost:4000/old/%EB%A7%A4%EC%9D%BC%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/2018/08/19/%EB%A7%A4%EC%9D%BC%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%8B%A4%EB%A6%AC%EC%BD%98%EB%B0%B8%EB%A6%AC-%ED%8C%A8%ED%82%A4%EC%A7%80-%EB%AC%B8%EC%A0%9C-6.html">&lt;p&gt;&lt;em&gt;안녕하세요, 매일프로그래밍 이번주 문제입니다.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;간격(interval)로 이루어진 배열이 주어지면, 겹치는 간격 원소들을 합친 새로운 배열을 만드시오. 간격은 시작과 끝으로 이루어져 있으며 시작은 끝보다 작거나 같습니다.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Given a list of intervals, merge intersecting intervals.&lt;/em&gt;&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;em&gt;예제)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Input: [[2,4], [1,5], [7,9]]&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Output: [[1,5], [7,9]]&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Input: [[3,6], [1,3], [2,4]]&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Output: [[1,6]]&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;풀이를 보고 싶으시다면 &lt;a href=&quot;http://url6080.mailprogramming.com/wf/click?upn=5YNwhcR4-2FFhQA54IFFE-2FIijGnZEwyyYieIxIap6l3O-2FubN19fiIJSHHldST5hRdPve0FiwaKLwgjdueIqs2AudeqqijB2P7Tmj5RCqXyXqdOO9tCqdjxX-2FQFY0NN1OBApbekhSSuFmcUF-2BNW9SBGIklOYzOCuFV1TcM7m-2FP0s6R4-2BurlgC6SGFxVKT3kq-2FMP_Zgoc2ijnN3jtNTS7ITLZKrJdLqoKRo6qqLK1adFq7tfpr38XOwkbKCkAq6jc6J9893wuN437PImWjxoLznjg6VJzwVeK3ArtZbu95oSlmxLo-2Fyz7C1HBtyi9VRRg6dAPq79xWck8RwHp0-2FCFF57KyPQnqbulzQNnqs2tvg4PAUuU5LsIPN5V9p6WCU7-2B6J7SvY-2B-2F-2FfJ1igoHPJ5W4RP-2FwK-2BIW0yWAfGuCCbLKN-2BYksDeFL1nb0NOFV8q1iDVmI3Z&quot;&gt;풀이보기&lt;/a&gt;를 눌러주세요.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;무슨… 말인가?&lt;/p&gt;

&lt;p&gt;[1,2,3,4,5,6,7,8,9]에서 첫 번째 예시를 보자&lt;/p&gt;

&lt;p&gt;[1,&lt;strong&gt;&lt;em&gt;2&lt;/em&gt;&lt;/strong&gt;,&lt;strong&gt;&lt;em&gt;3&lt;/em&gt;&lt;/strong&gt;,&lt;strong&gt;&lt;em&gt;4&lt;/em&gt;&lt;/strong&gt;,5,6,7,8,9]&lt;/p&gt;

&lt;p&gt;[&lt;strong&gt;&lt;em&gt;1&lt;/em&gt;&lt;/strong&gt;,&lt;strong&gt;&lt;em&gt;2&lt;/em&gt;&lt;/strong&gt;,&lt;strong&gt;&lt;em&gt;3&lt;/em&gt;&lt;/strong&gt;,&lt;strong&gt;&lt;em&gt;4&lt;/em&gt;&lt;/strong&gt;,&lt;strong&gt;&lt;em&gt;5&lt;/em&gt;&lt;/strong&gt;,6,7,8,9]&lt;/p&gt;

&lt;p&gt;[1,2,3,4,5,6,&lt;strong&gt;&lt;em&gt;7&lt;/em&gt;&lt;/strong&gt;,&lt;strong&gt;&lt;em&gt;8&lt;/em&gt;&lt;/strong&gt;,&lt;strong&gt;&lt;em&gt;9&lt;/em&gt;&lt;/strong&gt;]&lt;/p&gt;

&lt;p&gt;영문 문제에도 있듯, merge 하라는 말인 것 같다. git에서 merge를 한두번 써본 사람이라면 대충 개념을 알 것이다. 고등학교 수학으로 치면 &lt;strong&gt;합집합 구해라&lt;/strong&gt; 정도로 이해하면 될 것 같다. 다만 다른 점은 순서가 있다는 점이다.&lt;/p&gt;

&lt;p&gt;중괄호가 어색하니 파이썬 기준으로 다음과 같은 형태의 배열이 입출력된다고 하자.&lt;/p&gt;

&lt;p&gt;[(2,4), (1,5), (7,9)] =&amp;gt; [(1,5), (7,9)]&lt;/p&gt;

&lt;p&gt;일단 두 원소를 합치는 함수를 짜보았다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;unit_merge&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;or&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;min&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]),&lt;/span&gt;
                 &lt;span class=&quot;nb&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]))]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;이 unit_merge 함수를 이용해서 주어진 배열을 하나씩 합치려고 했지만, 앞의 원소가 합쳐지지 않은 경우 unit_merge의 호출 횟수가 기하급수적으로 늘어났다. 예를 들어 앞에서 합치지 못해서 [(a,b),(b+2,c)]인 경우, 다음 원소가 (b+1,b+2) 이면 이를 각각의 원소를 1:1로 합친 결과는 [(a,b+2),(b+1,c)] 가 되는데, 이 결과값은 기준을 만족하는 결과가 아니기 때문에 다시 unit_merge를 호출해야 한다.&lt;/p&gt;

&lt;p&gt;이 방법보다는 전체 리스트에서 가장 작은 숫자와 가장 큰 숫자의 범위를 찾아내 그 리스트 중에서 각 원소의 범위에 해당하는 숫자들을 찾아 그 범위를 정리하는 방법을 생각해 봤다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;merge&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;intervals&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;i0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[],&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;intervals&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;i0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;i1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;go&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;min&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;end&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;go&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;bl&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;bl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;False&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;enumerate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;intervals&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;bl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;bl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;insert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;False&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;bl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;False&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;i0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[],&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;enumerate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;or&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;continue&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]:&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;i0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]:&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;i1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;merged_internals&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;enumerate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;merged_internals&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]))&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;merged_internals&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;… 정말 더러운 코드가 탄생했다. 논리적으로 무조건 작동하는 코드지만, 시간복잡도는 O(n*log(n)) 정도 되지 않을까 한다. 잘 모르겠다. 각 인터벌 원소의 값에 따라 한 부분이 크게 바뀌어서 말이다. O(n^2)보다는 분명 작다.&lt;/p&gt;

&lt;p&gt;공간복잡도틑 O(n) 이지 않을까 싶다.&lt;/p&gt;

&lt;p&gt;이제 풀이를 보자.&lt;/p&gt;

&lt;p&gt;풀이에서는 문제의 어려운 점을 원소가 무작위적으로 배치되어 있는 부분이라 보았다. 이런 경우 자료구조를 통해 무작위의 원소를 정리하거나, 원소들을 정렬(sort)하면 된다고 한다.&lt;/p&gt;

&lt;p&gt;먼저 주어진 배열의 시작값을 기준으로 정렬한 후, 하나씩 차례대로 현재 원소의 종료 값과 다음 원소의 시작 값을 비교하여 합치면 된다… 고 한다. 하라는 대로 해보자. labmda와 sorted() 메서드를 이용해 시작값 기준으로 정렬한 후, 종료값과 다음 시작값을 비교해서 합칠지 구분할지를 판별하는 코드다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;sol&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;intervals&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;sorted_intervals&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;sorted&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;intervals&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;lambda&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;interval&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;interval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;merged_intervals&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sorted_i&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;enumerate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sorted_intervals&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;merged_intervals&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sorted_i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;continue&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;merged_intervals&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sorted_i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;merged_intervals&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sorted_i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;merged_intervals&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;merged_intervals&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sorted_i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;merged_intervals&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;훨씬 간단해졌다.&lt;/p&gt;</content><author><name></name></author><category term="매일프로그래밍" /><category term="mailprogramming" /><summary type="html">안녕하세요, 매일프로그래밍 이번주 문제입니다. 간격(interval)로 이루어진 배열이 주어지면, 겹치는 간격 원소들을 합친 새로운 배열을 만드시오. 간격은 시작과 끝으로 이루어져 있으며 시작은 끝보다 작거나 같습니다. Given a list of intervals, merge intersecting intervals.</summary></entry><entry><title type="html">매일프로그래밍 실리콘밸리 패키지 문제 5</title><link href="http://localhost:4000/old/%EB%A7%A4%EC%9D%BC%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/2018/08/16/%EB%A7%A4%EC%9D%BC%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%8B%A4%EB%A6%AC%EC%BD%98%EB%B0%B8%EB%A6%AC-%ED%8C%A8%ED%82%A4%EC%A7%80-%EB%AC%B8%EC%A0%9C-5.html" rel="alternate" type="text/html" title="매일프로그래밍 실리콘밸리 패키지 문제 5" /><published>2018-08-16T00:00:00+09:00</published><updated>2018-08-16T00:00:00+09:00</updated><id>http://localhost:4000/old/%EB%A7%A4%EC%9D%BC%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/2018/08/16/%EB%A7%A4%EC%9D%BC%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%8B%A4%EB%A6%AC%EC%BD%98%EB%B0%B8%EB%A6%AC-%ED%8C%A8%ED%82%A4%EC%A7%80-%EB%AC%B8%EC%A0%9C-5</id><content type="html" xml:base="http://localhost:4000/old/%EB%A7%A4%EC%9D%BC%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/2018/08/16/%EB%A7%A4%EC%9D%BC%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%8B%A4%EB%A6%AC%EC%BD%98%EB%B0%B8%EB%A6%AC-%ED%8C%A8%ED%82%A4%EC%A7%80-%EB%AC%B8%EC%A0%9C-5.html">&lt;p&gt;&lt;em&gt;안녕하세요, 매일프로그래밍 이번주 문제입니다.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;정수 배열과 타겟 숫자가 주어지면, 합이 타겟값이 되는 두 원소의 인덱스를 찾으시오.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;단, 시간복잡도 O(n) 여야 합니다.&lt;/em&gt;&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;em&gt;예제)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Input: [2, 5, 6, 1, 10], 타겟 8&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Output: [0, 2] // 배열[0] + 배열[2] = 8&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;풀이를 보고 싶으시다면 &lt;a href=&quot;http://url6080.mailprogramming.com/wf/click?upn=5YNwhcR4-2FFhQA54IFFE-2FIijGnZEwyyYieIxIap6l3O-2BZn5AMtZ2VbwOCB-2FZiACtFk31Hm92xuNMDnVdoIH3LRJqFxHEo0DTfdy5aRq5IOh8KsCj-2FRfPGhUHp3X11aa-2BW6zQEF2dsTmUG-2FqVD9AcyG79Lkb7E-2FZW-2BVbuS2jkj22RYAF8HkQ-2F-2F5UUQ60pOdfAv_Zgoc2ijnN3jtNTS7ITLZKrJdLqoKRo6qqLK1adFq7tfK9Nt-2FA8Fm5b8JV9XQcPgX6Fdc06-2FHgQggKToKPYzVYO0lUJzBc2zn1dSTl6CmzQ3-2FI9kSHlFrpYUqydDmvmMS5owpamn9HC9dHI-2B-2FeLMvroGaMvCpPf351GDa6cKlSr-2BS43SAIRodwc0dipUt87oR0n488Y8jmZyYzxBBxWuPDxmiTjQqwS6zuSWM0mUd91tqXf54wdC4PjP2Q2m8Xmd8&quot;&gt;풀이보기&lt;/a&gt;를 눌러주세요.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;배고프다.&lt;/p&gt;

&lt;p&gt;그러니까, 무조건 주어진 배열 안에 타겟 숫자가 되는 두 수가 있다는 뜻인가…?&lt;/p&gt;

&lt;p&gt;만약 그렇다면 너무 간단하다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def pair(arr, n):
    d_arr = dict()
    for i, j in enumerate(arr):
        d_arr[j] = i
    for i, j in enumerate(arr):
        return d_arr[j], d_arr[n-j]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;사실 도저히 시간복잡도를 O(n)로 할 수 있는 코드가 생각나지 않아 풀이를 봤다.&lt;/p&gt;

&lt;p&gt;풀이에서는 자바의 해쉬맵을 사용했는데, 해쉬테이블과의 차이는 다음과 같다(&lt;a href=&quot;https://stackoverflow.com/questions/40471/differences-between-hashmap-and-hashtable&quot;&gt;출처&lt;/a&gt;)&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;해쉬테이블은 동기화되어 있지만, 해쉬맵은 아니다. 이런 차이점은 해쉬맵을 단일 스레레드 애플리케이션에서 해쉬맵이 더 낫게 해 준다. 동기화되지 않은 객체들이 일반적으로 그렇지 않은 것들 보다 더 나은 성능을 보인다. Hashtable is synchronized, whereas HashMap is not. This makes HashMap better for non-threaded applications, as unsynchronized Objects typically perform better than synchronized ones.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;해쉬테이블은 nul 키 혹은 null 값을 허용하지 않는다. 해쉬맵은 하나의 null 키와 다수의 null 값을 허용한다. Hashtable does not allow null keys or values.  HashMap allows one null key and any number of null values.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;해쉬맵의 하위 클래스 중 하나가 LinkedHashMap인데, 만약 예측 가능한 iteration 순서가 요구될 경우, 쉽게 해쉬맵을 LinkedHashMap으로 교체할 수 있다. 이것은 만약 해쉬테이블이었다면 쉽지 않았을 것이다. One of HashMap’s subclasses is LinkedHashMap, so in the event that you’d want predictable iteration order (which is insertion order by default), you could easily swap out the HashMap for a LinkedHashMap. This wouldn’t be as easy if you were using Hashtable.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;파이썬에서 해쉬테이블을 구현한 것이 Dictionary라고 한다. 해쉬테이블이란 별게 아니라, Key를 참조해서 해당하는 값을 찾는 것이다. 이 경우 일반적으로 시간복잡도는 O(1)이기 때문에, O(n) * O(1) = O(n) 여서 문제의 조건을 만족한다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;if i in dict_including_i_as_a_key&lt;/code&gt;와 같은 구문은 파이썬3 에서는 시간복잡도가 &lt;em&gt;O(1)&lt;/em&gt; 이라고 한다.&lt;/p&gt;</content><author><name></name></author><category term="매일프로그래밍" /><category term="mailprogramming" /><summary type="html">안녕하세요, 매일프로그래밍 이번주 문제입니다. 정수 배열과 타겟 숫자가 주어지면, 합이 타겟값이 되는 두 원소의 인덱스를 찾으시오. 단, 시간복잡도 O(n) 여야 합니다.</summary></entry><entry><title type="html">매일프로그래밍 실리콘밸리 패키지 문제 4</title><link href="http://localhost:4000/old/%EB%A7%A4%EC%9D%BC%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/2018/08/16/%EB%A7%A4%EC%9D%BC%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%8B%A4%EB%A6%AC%EC%BD%98%EB%B0%B8%EB%A6%AC-%ED%8C%A8%ED%82%A4%EC%A7%80-%EB%AC%B8%EC%A0%9C-4.html" rel="alternate" type="text/html" title="매일프로그래밍 실리콘밸리 패키지 문제 4" /><published>2018-08-16T00:00:00+09:00</published><updated>2018-08-16T00:00:00+09:00</updated><id>http://localhost:4000/old/%EB%A7%A4%EC%9D%BC%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/2018/08/16/%EB%A7%A4%EC%9D%BC%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%8B%A4%EB%A6%AC%EC%BD%98%EB%B0%B8%EB%A6%AC-%ED%8C%A8%ED%82%A4%EC%A7%80-%EB%AC%B8%EC%A0%9C-4</id><content type="html" xml:base="http://localhost:4000/old/%EB%A7%A4%EC%9D%BC%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/2018/08/16/%EB%A7%A4%EC%9D%BC%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%8B%A4%EB%A6%AC%EC%BD%98%EB%B0%B8%EB%A6%AC-%ED%8C%A8%ED%82%A4%EC%A7%80-%EB%AC%B8%EC%A0%9C-4.html">&lt;p&gt;&lt;em&gt;안녕하세요, 매일프로그래밍 이번주 문제입니다.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;정수(int)가 주어지면, 팰린드롬(palindrome)인지 알아내시오. 팰린드롬이란, 앞에서&lt;/em&gt;부터 읽으나 뒤에서부터 읽으나 같은 단어를 말합니다. 단, 정수를 문자열로 바꾸면 안됩니다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Given an integer, check if it is a palindrome.&lt;/em&gt;&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;em&gt;예제)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Input: 12345&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Output: False&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Input: -101&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Output: False&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Input: 11111&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Output: True&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Input: 12421&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;﻿&lt;em&gt;Output: True&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;풀이를 보고 싶으시다면 &lt;a href=&quot;http://url6080.mailprogramming.com/wf/click?upn=5YNwhcR4-2FFhQA54IFFE-2FIijGnZEwyyYieIxIap6l3O-2Bsq5nttYp-2Fb3NsRtXjeJ5rOXpMTc4Y6sTezhdVtpzLBR-2BhSPmZ7toRdQbQkyBiXvA1YzZ7Uhvu6DRfNTJguyBX0xlQW6JTuiplsLXr-2BJN04tg-2BusrFfvFFg5TVRIWtjXHXlyW-2FGyDhYQBD0IXBHi-2B6_Zgoc2ijnN3jtNTS7ITLZKrJdLqoKRo6qqLK1adFq7tf3YTDLwTZzsR8aECA63mlW-2F323i4BTiluBHrMHdhBCZM41dBT-2Fq2PoFb1cLtrxFIB-2BRQcvRnKTjacbtjTAVEBx-2Br6ziOxB64NWF-2BuQhHlrxJcPcTe4BJh8zGBo1oR1f1hM4sY4lGQdgqznrzvQviAXuLW2sdeFTq9q5zsVCmAE1-2FRZCu8msa-2FC11uFuR0c7Y39XJY3BS4-2FmxvGzDXR4881&quot;&gt;풀이보기&lt;/a&gt;를 눌러주세요.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;…문자열로 바꾸지 않고 말인가?&lt;/p&gt;

&lt;p&gt;일단, 두 번째 예제를 보면, 음수는 절대값이 펠린드롬이라도 안 되는 모양이다. 주어진 수를 재귀함수를 이용하여 하나씩 떼어 내 배열에 집어넣는 함수는 다음과 같다. 재귀함수를 이용하는 어떤 선을 넘은 기분이다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def mod(n,
        l = []):
    l.insert(0, n%10)
    if n &amp;lt; 10 :
        return l
    n = int(n/10)
    return mod(n, l)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;문자열로 바꾼게 아니라 그냥 숫자를 담은 배열로 바꾸었으니 Cheating은 아니다. 사실 이런 식이 아니면 다른 방법이 있는지?&lt;/p&gt;

&lt;p&gt;위의 함수를 이용하여 간단하게 비교하는 함수다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def isPalindrome(n):
    n_char = mod(n)

    if len(n_char) % 2 == 0:
        for i in range(int(len(n_char)/2)):
            if n_char[i] != n_char[-i-1]:
                return False
        return True
    else :
        for i in range(int((len(n_char)-1)/2)):
            if n_char[i] != n_char[-i-1]:
                return False
        return True
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;풀이의 알고리즘은 다음과 같았다. Python 3를 사용중인데, 정수끼리의 division인 데도 결과가 정수가 아니라서 불편해졌다. 예전이 좋았다. Python 2에서는 그저 몫 구하기였는데 말이다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def sol(n):
    if n &amp;lt; 0 or ( n % 10 == 0 and n != 0 ):
        return False
    revertedHalf = 0
    while( n &amp;gt; revertedHalf ) :
        revertedHalf = revertedHalf * 10 + n % 10
        n = int(n/10)
    return n == revertedHalf or n == revertedHalf/10
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;일단 음수인지, 0이 아닌데도 0으로 끝나지는 않는지 판별 후에, 일의 자리부터 역순의 배열을 가지는 &lt;em&gt;revertedHalf&lt;/em&gt; 를 생성하면서 n에서는 한 자리수씩 잘라낸다. 그러면 만약 짝수의 길이면 같아지는 순간이 올 것이고, 홀수개의 길이면 &lt;em&gt;revertedHalf&lt;/em&gt; 의 끝 한 자리를 잘라내 비교한다.&lt;/p&gt;

&lt;p&gt;시간복잡도는 n의 길이에 비례하므로 O(log n), 공간복잡도는 달랑 변수 하나 &lt;em&gt;revertedHalf&lt;/em&gt; 를 재활용하므로 O(1) 이라고 한다…&lt;/p&gt;</content><author><name></name></author><category term="매일프로그래밍" /><category term="mailprogramming" /><summary type="html">안녕하세요, 매일프로그래밍 이번주 문제입니다. 정수(int)가 주어지면, 팰린드롬(palindrome)인지 알아내시오. 팰린드롬이란, 앞에서부터 읽으나 뒤에서부터 읽으나 같은 단어를 말합니다. 단, 정수를 문자열로 바꾸면 안됩니다. Given an integer, check if it is a palindrome.</summary></entry><entry><title type="html">매일프로그래밍 실리콘밸리 패키지 문제 3</title><link href="http://localhost:4000/old/%EB%A7%A4%EC%9D%BC%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/2018/08/16/%EB%A7%A4%EC%9D%BC%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%8B%A4%EB%A6%AC%EC%BD%98%EB%B0%B8%EB%A6%AC-%ED%8C%A8%ED%82%A4%EC%A7%80-%EB%AC%B8%EC%A0%9C-3.html" rel="alternate" type="text/html" title="매일프로그래밍 실리콘밸리 패키지 문제 3" /><published>2018-08-16T00:00:00+09:00</published><updated>2018-08-16T00:00:00+09:00</updated><id>http://localhost:4000/old/%EB%A7%A4%EC%9D%BC%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/2018/08/16/%EB%A7%A4%EC%9D%BC%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%8B%A4%EB%A6%AC%EC%BD%98%EB%B0%B8%EB%A6%AC-%ED%8C%A8%ED%82%A4%EC%A7%80-%EB%AC%B8%EC%A0%9C-3</id><content type="html" xml:base="http://localhost:4000/old/%EB%A7%A4%EC%9D%BC%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/2018/08/16/%EB%A7%A4%EC%9D%BC%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%8B%A4%EB%A6%AC%EC%BD%98%EB%B0%B8%EB%A6%AC-%ED%8C%A8%ED%82%A4%EC%A7%80-%EB%AC%B8%EC%A0%9C-3.html">&lt;p&gt;세 번째 문제를 보자.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;안녕하세요, 매일프로그래밍 이번주 문제입니다.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;정수 n이 주어지면, n개의 여는 괄호 “(“와 n개의 닫는 괄호 “)”로 만들 수 있는 괄호 조합을 모두 구하시오. (시간 복잡도 제한 없습니다).&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Given an integer N, find the number of possible balanced parentheses with N opening and closing brackets.&lt;/em&gt;&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;em&gt;예제)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Input: 1&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Output: [”()”]&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Input: 2&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Output: [”(())”, “()()”]&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Input: 3&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Output: [”((()))”, “(()())”, “()(())”, “(())()”, “()()()”]&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;풀이를 보고 싶으시다면 &lt;a href=&quot;http://url6080.mailprogramming.com/wf/click?upn=5YNwhcR4-2FFhQA54IFFE-2FIijGnZEwyyYieIxIap6l3O8noeEwNOG2X1lAnxk2sV7XJRKAQQte2tIpiPWRjJsja26Eib00XOe6NDcC5ATJD5UIsLtgiqu1b04ucC0CiQ36ShQY15ZPMHj9dLlgMuCyxyZESTW4cvE5q4nVfNw3OrdA8X01r7OPfyxPXg9tJosL_Zgoc2ijnN3jtNTS7ITLZKrJdLqoKRo6qqLK1adFq7tfrph1swa2JoBrt-2Bv-2FqwwyWk7D8OWXNX99wBVuyQo9FXI5uPn6suh4tayGboPrTbtCN-2BNahX5uzdAdm-2BdPkZ4xHpu5MZZvnYdN4DFsy9DdoWEgTimoojF4o-2BLsCzy0kBK3FNVPD9LtlXz-2BHYaQ48856DY6UPHkO5fECXg4Z74-2F-2FkSrHVVwEDImDB-2BIXuy3kdzn-2FLeTJrMm1DITc7FPYVeeb&quot;&gt;풀이보기&lt;/a&gt;를 눌러주세요.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;조금 고민했는데, 결국 이전 괄호 조합에 &lt;em&gt;”()”&lt;/em&gt; 를 어디에 넣을 것인지 그 경우의 수를 파악하고 중복을 제거하면 어떻게든 만들 수 있어 보인다.&lt;/p&gt;

&lt;p&gt;바로 작성해 보았다.&lt;/p&gt;

&lt;p&gt;…아니 모르겠다. 주어진 콸호들의 조합이 올바른 괄호인가에 대한 두 가지 함수를 만들었다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 단순하게 1) 짝수개인가? 2) 문자열 중 모든 ')'에 대해 그 앞에 '('가 있는지 확인

def isClosed(bra_arr):
    if len(bra_arr) % 2 != 0:
        return False
    count = 0
    for i, j in enumerate(bra_arr):
        if j == ')':
            count += 1
            if '(' not in bar_arr[0:i]:
                return False
    return True

# 전체 문자열에서 '()'를 하나씩 빼서 결국 빈 문자열이 되는지 확인: 재귀함수

def isClosed2(bar_arr):
    if bra_arr == '':
        return True
    elif '()' in bra_arr:
        bra_arr = bra_arr.replace('()','',1)
        return isClosed2(bra_arr)
    else :
        return False
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;일단 생성되는 &lt;em&gt;올바른 괄호들의 배열의 길이&lt;/em&gt; 가 어떻게 될지 모르겠다. 인터넷에서 답을 찾았다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;“이전 배열에서 각각의 원소를 ‘(…)’ 감싸던지, ‘()…’ 앞에 붙이던지, ‘…()’ 뒤에 붙이던지 하는 세 가지 경우가 있는데, 개중에 ‘()()’와 같이 반복되는 경우에만 ‘()()()’ 가 두 개 중복되므로 하나 제거하면 된다”&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;허탈해졌다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def braList(n):
    if n == 1:
        return ['()']
    else :
        bra_list = []
        for bb in braList(n-1):
            bra_list.append('(){}'.format(bb))
            bra_list.append('({})'.format(bb))
            if bb.replace('()','') != '':
                bar_list.append('{}()'.format(bb))
    return bra_list
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;잘 작동한다. 이제 풀이를 보자.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def parenthesisPairs(n,
                     ans = [],
                     cur = '',
                     open = 0,
                     close = 0):
    if (len(cur) == 2*n):
        ans.append(cur)
        return
    if open &amp;lt; n :
        parenthesisPairs( n, ans, cur + '(', open +1, close )
    if close &amp;lt; open :
        parenthesisPairs( n, ans, cur + ')', open, close +1 )
    return ans
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;재귀함수를 쓰기는 했는데.. 좀 다르다. n=2 인 경우를 보자.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;f([],'',0,0,2)
open &amp;lt; n
  f([],'(',1,0,2)
  open &amp;lt; n
    f([],'((',2,0,2)
    close &amp;lt; open
      f([],'(()',2,1,2)
      close &amp;lt; open
        f([],'(())',2,2,2)
        ans += ['(())']
  close &amp;lt; open
    f(['(())'],'()',1,1,2)
    open &amp;lt; n
      f(['(())'],'()(',2,1,2)
      close &amp;lt; open
        f(['(())'],'()()',2,2,2)
        ans += ['()()']
return ['(())','()()']
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이렇게 재귀함수를 한땀한땀 풀어 헤친 적은 처음이다… 무튼, 이렇게 해서 두 가지 조합이 출력된다.&lt;/p&gt;</content><author><name></name></author><category term="매일프로그래밍" /><category term="mailprogramming" /><summary type="html">세 번째 문제를 보자. 안녕하세요, 매일프로그래밍 이번주 문제입니다. 정수 n이 주어지면, n개의 여는 괄호 “(“와 n개의 닫는 괄호 “)”로 만들 수 있는 괄호 조합을 모두 구하시오. (시간 복잡도 제한 없습니다). Given an integer N, find the number of possible balanced parentheses with N opening and closing brackets.</summary></entry><entry><title type="html">매일프로그래밍 실리콘밸리 패키지 문제 2</title><link href="http://localhost:4000/old/%EB%A7%A4%EC%9D%BC%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/2018/08/16/%EB%A7%A4%EC%9D%BC%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%8B%A4%EB%A6%AC%EC%BD%98%EB%B0%B8%EB%A6%AC-%ED%8C%A8%ED%82%A4%EC%A7%80-%EB%AC%B8%EC%A0%9C-2.html" rel="alternate" type="text/html" title="매일프로그래밍 실리콘밸리 패키지 문제 2" /><published>2018-08-16T00:00:00+09:00</published><updated>2018-08-16T00:00:00+09:00</updated><id>http://localhost:4000/old/%EB%A7%A4%EC%9D%BC%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/2018/08/16/%EB%A7%A4%EC%9D%BC%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%8B%A4%EB%A6%AC%EC%BD%98%EB%B0%B8%EB%A6%AC-%ED%8C%A8%ED%82%A4%EC%A7%80-%EB%AC%B8%EC%A0%9C-2</id><content type="html" xml:base="http://localhost:4000/old/%EB%A7%A4%EC%9D%BC%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/2018/08/16/%EB%A7%A4%EC%9D%BC%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%8B%A4%EB%A6%AC%EC%BD%98%EB%B0%B8%EB%A6%AC-%ED%8C%A8%ED%82%A4%EC%A7%80-%EB%AC%B8%EC%A0%9C-2.html">&lt;p&gt;&lt;em&gt;안녕하세요, 매일프로그래밍 이번주 문제입니다.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;피보나치 배열은 0과 1로 시작하며, 다음 피보나치 수는 바로 앞의 두 피보나치 수의 합이 된다. 정수 N이 주어지면, N보다 작은 모든 짝수 피보나치 수의 합을 구하여라.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Fibonacci sequence starts with 0 and 1 where each fibonacci number is a sum of two previous fibonacci numbers.&lt;/em&gt; &lt;!--more--&gt;
&lt;em&gt;Given an integer N, find the sum of all even fibonacci numbers.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;예제)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Input: N = 12&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Output: 10 // 0, 1, 2, 3, 5, 8 중 짝수인 2 + 8 = 10.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;풀이를 보고 싶으시다면 &lt;a href=&quot;http://url6080.mailprogramming.com/wf/click?upn=5YNwhcR4-2FFhQA54IFFE-2FIijGnZEwyyYieIxIap6l3O9vJxPRw2Bbchm-2FXdmgSQft-2Bw2wbwlUiRdKDFeKCWOx3hQSda8U5RH-2FO0rd-2FckaP7cdZkh-2Fbn0TmYIFa1D6w8k51qKoYp0oEExjPVL-2BzRcmhnd7cHK5LHxZJjuL-2FPZ4koZD3dnQbh1QZ2bCq0gXPKcp_Zgoc2ijnN3jtNTS7ITLZKrJdLqoKRo6qqLK1adFq7tfD9Ex2fUtQRIDUt54tFWpSMJd5tuojrvDCtuqH8gC2SUsAW6Y502j2zWGTV8fOc5Rmt4hEgRFOoh4rnpcute5bvZHc8dICLP4TCk-2Fs9MzVYROeNvLcc8-2BzO-2FSzV0ThU00lGBmqBnOIsQ9tufGXGqc5PklrVteNFtWQ-2F7Zd6DbLf1nY-2BU-2BA5rzZosZ6N-2BAQ1iY6WdiE5vOuBlmYFS-2Fkj8k8&quot;&gt;풀이보기&lt;/a&gt;를 눌러주세요.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;사실 밀린 문제를 풀고 있다.&lt;/p&gt;

&lt;p&gt;맨 처음 떠오르는 생각은 &lt;em&gt;재귀함수&lt;/em&gt; 다. 자신을 콜하는 함수. N-2 째와 N-1 째까지 스스로를 호출하여 그 합을 N번째 피보나치 수로 출력하면 일단 뭐든 될것 같다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def fibo(n):
    if (n == 1):
        return 0
    elif (n == 2):
        return 1
    else :
        return fibo(n-2) + fibo(n-1)

if __name__ == '__main__':
    n = 12
    for i in range(1, n):
        print(fibo(i))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;간단하게 작성한 n번째 피보나치 수열을 구하는 코드이다. 12번째까지 구한다. 그러나 최적화된 코드는 아니다. n번째 수열을 구하기 위해서는 &lt;em&gt;fibo()&lt;/em&gt; 메서드를 호출하는 횟수가 빠르게 증가함을 알 수 있다. 이때 시간복잡도는 대략 O(2^n)이 된다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;fibo()&lt;/th&gt;
      &lt;th&gt;Called&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;fibo(0)&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;fibo(1)&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;fibo(2)&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;fibo(4)&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;fibo(5)&lt;/td&gt;
      &lt;td&gt;8&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;fibo(6)&lt;/td&gt;
      &lt;td&gt;13&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;fibo(7)&lt;/td&gt;
      &lt;td&gt;22&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;일단 문제에서 요구하는 풀이를 작성해 보자.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if __name__ == '__main__':
    # n = 12
    # for i in range(1, n):
    #     print(fibo(i))

    n = 1200
    i = 0
    sum = 0
    while (True):
        i += 1
        fibo_i = fibo(i)
        if (fibo_i &amp;lt; n):
            if (fibo_i % 2 == 0):
                sum += fibo_i
        else :
            print(sum)
            break
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;출력 결과는 798로, 맞다. for문이 아니라 while 문을 한 이유는, 종료 기준이 적당한게 없다고 판단해서다. 그다지 효율적인 코드는 아닌데, While 문의 매 루프마다 fibo() 메서드가 그때까지의 모든 항을 다시 전부 구하기 때문이다. 다음과 같이 배열을 만들어 저장하는 코드를 사용하면, 시간복잡도는 좀 더 효율적인 O(n)이 된다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def fiboArr(n):
    fiboList = [0,1]
    if (n &amp;lt;2):
        try :
            return fiboList[n-1]
        except IndexError:
            print('n must be netural number.')
            return
    else:
        for i in range(2, n+1):
            fiboList.append( fiboList[i-2] + fiboList[i-1] )

    return fiboList[-1]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이제 풀이를 참고해 보자. 풀이 코드는 유료이므로 앞으로도 대략적인 알고리즘만 공유할 생각이다. 원래 코드는 자바로 되어 있다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def eventFibSum(n):
    sum = 0
    x = 1
    y = 2
    while (x &amp;lt; n):
        if (x % 2 == 0):
            sum += x
        x, y = y, x + y
    return sum
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;본인의 코드는 너무 길다.&lt;/p&gt;</content><author><name></name></author><category term="매일프로그래밍" /><category term="mailprogramming" /><summary type="html">안녕하세요, 매일프로그래밍 이번주 문제입니다. 피보나치 배열은 0과 1로 시작하며, 다음 피보나치 수는 바로 앞의 두 피보나치 수의 합이 된다. 정수 N이 주어지면, N보다 작은 모든 짝수 피보나치 수의 합을 구하여라. Fibonacci sequence starts with 0 and 1 where each fibonacci number is a sum of two previous fibonacci numbers.</summary></entry><entry><title type="html">매일프로그래밍 - 실리콘밸리 패키지 문제 1</title><link href="http://localhost:4000/old/%EB%A7%A4%EC%9D%BC%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/2018/08/15/%EB%A7%A4%EC%9D%BC%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%8B%A4%EB%A6%AC%EC%BD%98%EB%B0%B8%EB%A6%AC-%ED%8C%A8%ED%82%A4%EC%A7%80-%EB%AC%B8%EC%A0%9C-1.html" rel="alternate" type="text/html" title="매일프로그래밍 - 실리콘밸리 패키지 문제 1" /><published>2018-08-15T00:00:00+09:00</published><updated>2018-08-15T00:00:00+09:00</updated><id>http://localhost:4000/old/%EB%A7%A4%EC%9D%BC%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/2018/08/15/%EB%A7%A4%EC%9D%BC%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%8B%A4%EB%A6%AC%EC%BD%98%EB%B0%B8%EB%A6%AC-%ED%8C%A8%ED%82%A4%EC%A7%80-%EB%AC%B8%EC%A0%9C-1</id><content type="html" xml:base="http://localhost:4000/old/%EB%A7%A4%EC%9D%BC%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/2018/08/15/%EB%A7%A4%EC%9D%BC%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%8B%A4%EB%A6%AC%EC%BD%98%EB%B0%B8%EB%A6%AC-%ED%8C%A8%ED%82%A4%EC%A7%80-%EB%AC%B8%EC%A0%9C-1.html">&lt;p&gt;얼마 전에 매일프로그래밍이라는 곳을 구독했다. 매주 문제를 쏴주는데, 풀이가 유료인 듯 하다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;안녕하세요, 매일프로그래밍 이번주 문제입니다.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;정수 배열(int array)가 주어지면 가장 큰 이어지는 원소들의 합을 구하시오. 단, 시간복잡도는 O(n).&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Given an integer array, find the largest consecutive sum of elements.&lt;/em&gt;&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;em&gt;예제}&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Input: [-1, 3, -1, 5]&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Output: 7 // 3 + (-1) + 5&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Input: [-5, -3, -1]&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Output: -1 // -1&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Input: [2, 4, -2, -3, 8]&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Output: 9 // 2 + 4 + (-2) + (-3) + 8&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;풀이를 보고 싶으시다면 &lt;a href=&quot;http://url6080.mailprogramming.com/wf/click?upn=5YNwhcR4-2FFhQA54IFFE-2FIijGnZEwyyYieIxIap6l3O8JeZvrwl9GDvnsjUaV-2BpLL1Y2FzV0exFClJtIjQcnPXXxek-2BrqgN3HAkG97snJiyhOgL9AMM71UxduDtaEHp2KuqMiKQhQyqAQGb0xdWh8tH5cbofvd5mY5BjzZqFzqUUFfvl34U5rhSbZdwW1JE22_Zgoc2ijnN3jtNTS7ITLZKrJdLqoKRo6qqLK1adFq7tdzYResJrrXk8mlbCwT4OFO7nBg6u7yqNDlwHtmerSkb047tmQqe58DPufWrVcPno1cRbkyKm-2Fbqb1CxmlygfTd2eVKU6ALUJA-2FGvlZMEU-2F-2FYGecEqpcIMpOibluJygSM-2BFjTf5dQvkPntJZEcVhto3Q96Oiw28o8k4VdZ4LfLOjZ-2FCfN-2F4elwJYIvlxd7sQhTyWuxOw5upJKz08GnDMapq&quot;&gt;풀이보기&lt;/a&gt;를 눌러주세요&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;주어진 조건 중에 &lt;em&gt;시간복잡도는 O(n)&lt;/em&gt; 라는 게 있는데, 이건 n개의 일거리가 입력되었을 때걸리는 최대 시간을 T(n)라고 했을 때 n의 크기에 선형적으로 비례한다는 뜻이다. O(n)라는 표현은 빅-오 표기법이라 불린다. 더 쓰고 싶지만 본인이 깊이가 없어 링크로 대체한다 - &lt;a href=&quot;https://ko.wikipedia.org/wiki/%EC%8B%9C%EA%B0%84_%EB%B3%B5%EC%9E%A1%EB%8F%84&quot;&gt;위키피디아:시간복잡도&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;간단하게, 만약 T(n) = O(n^3) 이라면, n이 두배 많아지면 연산 시간은 8배 길어진다로 이해하면 된다. n * n 행렬 두 개의 곱셈을 예시로 들 수 있겠다. 1x1 행렬곱은 곱 연산을 한번 하는 것에 비해 2x2 행렬곱은 같은 곱연산을 8번 한다. 덧셈은? 많이 고민할 필요 없다. 곱셈한 만큼 그에 비례하여 덧셈도 하지 않겠는가? 빅-오 표현은 가장 큰 차수의 다항만 표시한다. 입력되는 n이 증가할 때 그 출력값이 얼마나 빨리 커지는지를 쉽게 알기 위한 표기법이니 비교적 영향이 적은 다른 차수는 무시된다.&lt;/p&gt;

&lt;p&gt;문제를 이해하기 위해, 첫 번째 예제를 보자. 처음 봤을때는 번역이 이상해서인지 이해가 더뎠다.&lt;/p&gt;

&lt;p&gt;Input: [-1, 3, -1, 5]&lt;/p&gt;

&lt;p&gt;Output: 7 // 3 + (-1) + 5&lt;/p&gt;

&lt;p&gt;이어지는 원소들의 합 중 제일 큰걸 찾아라, 정도로 이해하고 머리를 굴려 봤다.&lt;/p&gt;

&lt;p&gt;원소가 4개니 크기 2 이상의 연속한 부분집합은 다음 정도인 듯하다.&lt;/p&gt;

&lt;p&gt;[-1, 3], [3, -1], [-1, 5], [-1, 3, -1], [3, -1, 5], [-1, 3, -1, 5]&lt;/p&gt;

&lt;p&gt;각각의 배열의 합은 나열하면 순서대로 2, 2, 4, 1, 7, 6 이다. Output이 7인게 납득된다.&lt;/p&gt;

&lt;p&gt;길이가 2 이상이라는 생각은 다음 예제에서 오류임을 알았다. 하나의 원소만이어도 되는 모양이다.&lt;/p&gt;

&lt;p&gt;Input: [-5, -3, -1]&lt;/p&gt;

&lt;p&gt;Output: -1 // -1&lt;/p&gt;

&lt;p&gt;세 번째 예제는 원소가 5개인데, 이 배열의 연속한 배열인 부분집합은 1 + 2 + 3 + 4 + 5, 즉 15개다. 세 번째 예제를 굳이 검증해 보자..&lt;/p&gt;

&lt;p&gt;Input: [2, 4, -2, -3, 8]&lt;/p&gt;

&lt;p&gt;Output: 9 // 2 + 4 + (-2) + (-3) + 8&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;서브셋&lt;/th&gt;
      &lt;th&gt;합&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;[2, 4, -2, -3, 8]&lt;/td&gt;
      &lt;td&gt;9&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;[2, 4, -2, -3]&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;[4, -2, -3, 8]&lt;/td&gt;
      &lt;td&gt;7&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;[2, 4, -2]&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;[4, -2, -3]&lt;/td&gt;
      &lt;td&gt;-1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;[-2, -3, 8]&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;[2, 4]&lt;/td&gt;
      &lt;td&gt;6&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;[4, -2]&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;[-2, -3]&lt;/td&gt;
      &lt;td&gt;-5&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;[-3, 8]&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;[2]&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;[4]&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;[-2]&lt;/td&gt;
      &lt;td&gt;-2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;[-3]&lt;/td&gt;
      &lt;td&gt;-3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;[8]&lt;/td&gt;
      &lt;td&gt;8&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;확실히 9가 맞다. 문제를 다시 정의하자면, &lt;strong&gt;&lt;em&gt;연속하는 원소들의 합 중 제일 큰 걸 찾아라. 하나도 상관 없다&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;방법 1. 전체 합보다 맨 처음, 또는 맨 끝의 숫자를 제외했을 때의 합이 작을 경우, 그 하위 단계에서 합이 더 클 수 있는가?&lt;/p&gt;

&lt;p&gt;만약 그렇다고 하면 하위 단계에서 제외됨으로써 전체 합이 더 커지는 원소는 음수일 것이다. 이 수는 제외되기 전의 합에 포함되는 값이므로 맨 첫 단계에서 제외된 값보다 절대값이 큰 경우에 이후 단계의 합이 더 커지게 된다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;서브셋&lt;/th&gt;
      &lt;th&gt;합&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;[a, b, c, d, e]&lt;/td&gt;
      &lt;td&gt;a + b + c + d + e = s1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;[a, b, c, d]&lt;/td&gt;
      &lt;td&gt;a + b + c + d = s1 - e&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;[a, b, c]&lt;/td&gt;
      &lt;td&gt;a + b + c = s1 - e - d&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;s1 -e -d &amp;gt; s1?&lt;/p&gt;

&lt;p&gt;e+d가 음수이면 가능하다. 고로 방법 1은 탈락.&lt;/p&gt;

&lt;p&gt;방법 2. 꼼수 부리지 말자&lt;/p&gt;

&lt;p&gt;주어진 배열을 arr라고 하면 일단 가장 간단하게 생각할 수 있는 알고리즘은 모든 종류의 SubSet을 모두 구해서 각각 합을 구해 개중에 최대값을 구하는 것이다. 이 경우 시간복잡도는 O(n)보다 무조건 크게 된다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# mailprogramming/problem1.py

def test(arr):
    subArrs = []
    for i in range(len(arr)):
        for j in range(i+1,len(arr)+1):
            subArrs += [arr[i:j]]


    subSumList = []
    for subArr in subArrs:
        subSum = 0
        for i in subArr:
            subSum += i
        subSumList.append(subSum)


    maxSum = 0
    for s in subSumList:
        if (maxSum &amp;lt; s):
            maxSum = s

    return maxSum


if __name__ == '__main__':                                                      
    l = [2, 4,-2,-3, 8]                                                         

    print(test(l))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;잘 동작한다. 서브셋도 잘 구하고, 각 서브셋의 총합도 잘 구하고, 개중에 최대도 잘 구한다. 하지만 하지 않아도 되는 연산이 존재한다. 게다가 쓸데없이 코드가 너무 길다. 논리적으로는 틀릴 수 없는 코드지만, 이러한 비효율적인 부분을 제거해야 비로소 좋은 코드가 아닐까 한다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;굳이 더하지 않더라도&lt;/em&gt; &lt;strong&gt;&lt;em&gt;음수&lt;/em&gt;&lt;/strong&gt; &lt;em&gt;면 당연히 합이 작아질 것이 아닌가?&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;맨 첫 원소부터 시작해보자. 2를 내 &lt;em&gt;Sum&lt;/em&gt; 이라는 주머니에 담아뒀다. 다음 숫자가 양수이니 더하면 더 커질 것이다. 담는다. 합은 6이 된다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;서브셋&lt;/th&gt;
      &lt;th&gt;합&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;[2]&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;2&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;[4]&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;[-2]&lt;/td&gt;
      &lt;td&gt;-2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;[-3]&lt;/td&gt;
      &lt;td&gt;-3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;[8]&lt;/td&gt;
      &lt;td&gt;8&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;[2, 4]&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;6&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;현재 챔피언 서브셋(합이 가장 큰 서브셋을, 유치하지만 이렇게 부르자)은 [2,4] 이고, 총합은 6이다. 다음 연속하는 원소를 보자. -4다. 음수니까 더하면 작아지니 버리는게 낫지 않겠는가? 아직 알 수 없다. -4를 포함한 다음 원소가 무지막지하게 커서, -4의 네거티브한 영향을 흔적도 없이 상쇄할 수도 있기 때문이다. 더해서, 합은 4가 된다. 아직 최대값은 6이다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Cont.&lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;[4, -2]&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;[-2, -3]&lt;/td&gt;
      &lt;td&gt;-5&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;[-3, 8]&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;[2, 4, -2]&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;4&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;다음을 보자. -3이다. 더하면, 최종 합 1이다. 마지막 원소에 희망을 가져 보자.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Cont.&lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;[4, -2, -3]&lt;/td&gt;
      &lt;td&gt;-1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;[-2, -3, 8]&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;[2, 4, -2, -3]&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;마지막 원소는 기다린 보람이 있다. 8이다. 이로써 최종 합은 9가 되었고, 최대 서브셋 챔피언은 [2, 4, -2, -3, 8]가 되었다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Cont.&lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;[4, -2, -3, 8]&lt;/td&gt;
      &lt;td&gt;7&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;[2, 4, -2, -3, 8]&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;9&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;덧셈 연산을 5번 밖에 안 했다. 미심쩍은가? 만약 &lt;em&gt;Sum&lt;/em&gt; 주머니에 들어있는게 양수면, 다음 원소가 무엇이든 그 합은 더 커질 것이니 더하면 되고, 그렇지 않고 음수라면 그 합은 무조건 더 작아지니 더할 필요가 없다. 다음 원소를 그냥 새로운 &lt;em&gt;Sum&lt;/em&gt; 에 대입하면 된다. 최대 값의 &lt;em&gt;Sum&lt;/em&gt; 을 따로 저장해놓고 있기 때문에, 다음 값이 음수라서 &lt;em&gt;Sum&lt;/em&gt; 이 작아지더라도 최대 &lt;em&gt;Sum&lt;/em&gt; 값을 잃어버릴 일은 없다.&lt;/p&gt;

&lt;p&gt;이 두 가지 규칙만으로 항상 &lt;strong&gt;최대 연속 합&lt;/strong&gt; 을 구할 수 있다. 사실 대소를 비교하는 것도 정확히는 덧셈 연산이나, 그럼에도 비교하는 횟수는 배열의 길이에 선형적으로 비례하여 증가한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def sol(arr):                                                                   
sum = arr[0]                                                                
maxSum = arr[0]                                                             
for i in range(1, len(arr)):                                                
    if (sum &amp;gt; 0):                                                           
        sum = sum + arr[i]                                                  
    else :                                                                  
        sum = arr[i]                                                        

    if (sum &amp;gt; maxSum):                                                      
        maxSum = sum                                                        

return maxSum
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;시간 복잡도는 O(n), 공간복잡도는 O(1) 이다. 사용하는 변수의 개수가 배열의 길이에 상관없이 단 2개면 되니 n의 함수가 더이상 아니다.&lt;/p&gt;

&lt;p&gt;사실 이 솔루션은 사이트에서 제공하는 솔루션을 나름대로 고민하다 얻었다. 무척 단순한 논리로 최적의 솔루션을 구할 수 있었다.&lt;/p&gt;</content><author><name></name></author><category term="매일프로그래밍" /><category term="mailprogramming" /><summary type="html">얼마 전에 매일프로그래밍이라는 곳을 구독했다. 매주 문제를 쏴주는데, 풀이가 유료인 듯 하다. 안녕하세요, 매일프로그래밍 이번주 문제입니다. 정수 배열(int array)가 주어지면 가장 큰 이어지는 원소들의 합을 구하시오. 단, 시간복잡도는 O(n). Given an integer array, find the largest consecutive sum of elements.</summary></entry></feed>